// Targeted by JavaCPP version 1.5.8: DO NOT EDIT THIS FILE

package io.nanodbc.javacpp.generated;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class NanodbcNative extends io.nanodbc.javacpp.NanodbcConfig {
    static { Loader.load(); }

@Name("std::list<std::wstring>") public static class StringList extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringList(Pointer p) { super(p); }
    public StringList()       { allocate();  }
    private native void allocate();
    public native @Name("operator =") @ByRef StringList put(@ByRef StringList x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native @ByVal Iterator insert(@ByVal Iterator pos, @StdWString CharPointer value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator ++") @ByRef Iterator increment();
        public native @Name("operator ==") boolean equals(@ByRef Iterator it);
        public native @Name("operator *") @StdWString CharPointer get();
    }
}

@Name("std::list<nanodbc::datasource>") public static class DatasourceList extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DatasourceList(Pointer p) { super(p); }
    public DatasourceList()       { allocate();  }
    private native void allocate();
    public native @Name("operator =") @ByRef DatasourceList put(@ByRef DatasourceList x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native @ByVal Iterator insert(@ByVal Iterator pos, @ByRef Datasource value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator ++") @ByRef Iterator increment();
        public native @Name("operator ==") boolean equals(@ByRef Iterator it);
        public native @Name("operator *") @ByRef @Const Datasource get();
    }
}

@Name("std::list<nanodbc::driver>") public static class DriverList extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DriverList(Pointer p) { super(p); }
    public DriverList()       { allocate();  }
    private native void allocate();
    public native @Name("operator =") @ByRef DriverList put(@ByRef DriverList x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native @ByVal Iterator insert(@ByVal Iterator pos, @ByRef Driver value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator ++") @ByRef Iterator increment();
        public native @Name("operator ==") boolean equals(@ByRef Iterator it);
        public native @Name("operator *") @ByRef @Const Driver get();
    }
}

@Name("std::list<nanodbc::driver::attribute>") public static class DriverAttributeList extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DriverAttributeList(Pointer p) { super(p); }
    public DriverAttributeList()       { allocate();  }
    private native void allocate();
    public native @Name("operator =") @ByRef DriverAttributeList put(@ByRef DriverAttributeList x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native @ByVal Iterator insert(@ByVal Iterator pos, @ByRef Driver.Attribute value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator ++") @ByRef Iterator increment();
        public native @Name("operator ==") boolean equals(@ByRef Iterator it);
        public native @Name("operator *") @ByRef @Const Driver.Attribute get();
    }
}

@Name("std::vector<uint8_t>") public static class UInt8Vector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UInt8Vector(Pointer p) { super(p); }
    public UInt8Vector(byte value) { this(1); put(0, value); }
    public UInt8Vector(byte ... array) { this(array.length); put(array); }
    public UInt8Vector()       { allocate();  }
    public UInt8Vector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator =") @ByRef UInt8Vector put(@ByRef UInt8Vector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @Cast("uint8_t") byte get(@Cast("size_t") long i);
    public native UInt8Vector put(@Cast("size_t") long i, byte value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @Cast("uint8_t") byte value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator ++") @ByRef Iterator increment();
        public native @Name("operator ==") boolean equals(@ByRef Iterator it);
        public native @Name("operator *") @Cast("uint8_t") byte get();
    }

    public byte[] get() {
        byte[] array = new byte[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public byte pop_back() {
        long size = size();
        byte value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public UInt8Vector push_back(byte value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public UInt8Vector put(byte value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public UInt8Vector put(byte ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

// Parsed from nanodbc/nanodbc.h

/** \file nanodbc.h The entirety of nanodbc can be found within this file and nanodbc.cpp.
 <p>
 *  \mainpage
 * 
 *  \section synopsis Synopsis
 *  This library provides a wrapper API for the native ODBC API. It aims to do everything ODBC does,
 *  but with a \b much nicer interface. Anything it doesn't (yet) do can be done by retrieving the
 *  native ODBC handles and dropping down to straight ODBC C API code.
 *  For more propaganda, please see the <a href="http://nanodbc.io/">project
 *  homepage</a>.
 * 
 *  \section toc Table of Contents
 *  - \ref license "License"
 *  - \ref credits "Credits"
 *  - Source level documentation:
 *      - \ref nanodbc "nanodbc namespace"
 *      - \ref exceptions
 *      - \ref utility
 *      - \ref mainc
 *      - \ref mainf
 *      - \ref binding
 *      - \ref bind_multi
 *      - \ref bind_strings
 * 
 *  \section license License
 *  <div class="license">
 *  Copyright (C) 2013 lexicalunit <lexicalunit\lexicalunit.com>
 * 
 *  The MIT License
 * 
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *  </div>
 * 
 *  \section credits Credits
 *  <div class="license">
 *  Much of the code in this file was originally derived from TinyODBC.
 *  TinyODBC is hosted at http://code.google.com/p/tiodbc/
 *  Copyright (C) 2008 SqUe squarious\gmail.com
 *  License: The MIT License
 * 
 *  The idea for using RAII for transactions was inspired by SimpleDB: C++ ODBC database API,
 *  however the code in nanodbc is original and not derived from SimpleDB. Therefore
 *  the LGPL license under which SimpleDB is distributed does NOT apply to nanodbc.
 *  SimpleDB is hosted at http://simpledb.sourceforge.net
 *  Copyright (C) 2006 Eminence Technology Pty Ltd
 *  Copyright (C) 2008-2010,2012 Russell Kliese russell\kliese.id.au
 *  License: GNU Lesser General Public version 2.1
 * 
 *  Some improvements and features are based on The Python ODBC Library.
 *  The Python ODBC Library is hosted at http://code.google.com/p/pyodbc/
 *  License: The MIT License
 * 
 *  Implementation of column binding inspired by Nick E. Geht's source code posted to on CodeGuru.
 *  GSODBC hosted at http://www.codeguru.com/mfc_database/gsodbc.html
 *  Copyright (C) 2002 Nick E. Geht
 *  License: Perpetual license to reproduce, distribute, adapt, perform, display, and sublicense.
 *  See http://www.codeguru.com/submission-guidelines.php for details.
 *  </div> */

// #ifndef NANODBC_H
// #define NANODBC_H

// #include <cstddef>
// #include <functional>
// #include <list>
// #include <memory>
// #include <stdexcept>
// #include <string>
// #include <vector>

// #ifndef __clang__

///
// #include <cstdint>
// #endif

/** \brief The entirety of nanodbc can be found within this one namespace.
 * 
 *  \note This library does not make any exception safety guarantees, but should work just fine with
 *        a threading enabled ODBC driver. If you want to use nanodbc objects in threads I recommend
 *        each thread keep their own connection to the database. Otherwise you must synchronize any
 *        access to nanodbc objects. */

// clang-format off
//  .d8888b.                     .d888 d8b                                   888    d8b
// d88P  Y88b                   d88P"  Y8P                                   888    Y8P
// 888    888                   888                                          888
// 888         .d88b.  88888b.  888888 888  .d88b.  888  888 888d888 8888b.  888888 888  .d88b.  88888b.
// 888        d88""88b 888 "88b 888    888 d88P"88b 888  888 888P"      "88b 888    888 d88""88b 888 "88b
// 888    888 888  888 888  888 888    888 888  888 888  888 888    .d888888 888    888 888  888 888  888
// Y88b  d88P Y88..88P 888  888 888    888 Y88b 888 Y88b 888 888    888  888 Y88b.  888 Y88..88P 888  888
//  "Y8888P"   "Y88P"  888  888 888    888  "Y88888  "Y88888 888    "Y888888  "Y888 888  "Y88P"  888  888
//                                              888
//                                         Y8b d88P
//                                          "Y88P"
// MARK: Configuration -
// clang-format on

/** \addtogroup macros Macros
 *  \brief Configuration and utility macros that nanodbc uses, can be overriden by users.
 * 
 *  \{ */
// #ifdef DOXYGEN

/** \def NANODBC_THROW_NO_SOURCE_LOCATION
/** \brief Configures \c nanodbc::database_error message
/**
/** If defined, removes source file name and line number from \c nanodbc::database_error message
/** By default, nanodbc includes source location of exception in the error message. */

///
///
// #define NANODBC_THROW_NO_SOURCE_LOCATION 1

/** \def NANODBC_ASSERT(expression)
 *  \brief Assertion.
 * 
 *  By default, nanodbc uses C \c assert() for internal assertions.
 *  User can override it by defining \c NANODBC_ASSERT(expr) macro
 *  in the nanodbc.h file and customizing it as desired,
 *  before building the library.
 * 
 *  <pre>{@code {.cpp}
 *  #ifdef _DEBUG
 *      #include <crtdbg.h>
 *      #define NANODBC_ASSERT _ASSERTE
 *  #endif
 *  }</pre> */
// #define NANODBC_ASSERT(expression) assert(expression)

// #endif
/** \} */

// #if __cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
// #ifndef NANODBC_SUPPORT_STRING_VIEW
// #define NANODBC_SUPPORT_STRING_VIEW
// #endif
// #endif

// You must explicitly request Unicode support by defining NANODBC_ENABLE_UNICODE at compile time.
// #ifndef DOXYGEN
// #ifdef NANODBC_ENABLE_UNICODE
// #ifdef NANODBC_USE_IODBC_WIDE_STRINGS
// #define NANODBC_TEXT(s) U##s
// #ifdef NANODBC_SUPPORT_STRING_VIEW
// #endif
// #else
// #ifdef _MSC_VER
// #ifdef NANODBC_SUPPORT_STRING_VIEW
// #endif
// #define NANODBC_TEXT(s) L##s
// #else
// #endif
// #endif
// #else
// #endif

// #ifdef NANODBC_USE_IODBC_WIDE_STRINGS
// #ifdef NANODBC_SUPPORT_STRING_VIEW
// #endif
// #else
// #ifdef _MSC_VER
// #ifdef NANODBC_SUPPORT_STRING_VIEW
// #endif
// #else
// #endif
// #endif

// #if defined(_WIN64)
// LLP64 machine: Windows
// #elif !defined(_WIN64) && defined(__LP64__)
// LP64 machine: OS X or Linux
// #else
// 32-bit machine

///
// #endif
// #else
/** \def NANODBC_TEXT(s)
 *  \brief Creates a string literal of the type corresponding to {@code nanodbc::string}.
 * 
 *  By default, the macro maps to an unprefixed string literal.
 *  If building with options NANODBC_ENABLE_UNICODE=ON and
 *  NANODBC_USE_IODBC_WIDE_STRINGS=ON specified, then it prefixes a literal with U"...".
 *  If only NANODBC_ENABLE_UNICODE=ON is specified, then:
 *    * If building with Visual Studio, then the macro prefixes a literal with L"...".
 *    * Otherwise, it prefixes a literal with u"...". */

///
// #define NANODBC_TEXT(s) s

/** \c string will be \c std::u16string or \c std::32string if \c NANODBC_ENABLE_UNICODE
 *  defined.
 * 
 *  Otherwise it will be \c std::string. */
/** \c null_type will be \c int64_t for 64-bit compilations, otherwise \c long. */
// #endif

// #if __cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
// [[deprecated]] is only available in C++14
// #define NANODBC_DEPRECATED [[deprecated]]
// #else
// #ifdef __GNUC__
// #define NANODBC_DEPRECATED __attribute__((deprecated))
// #elif defined(_MSC_VER)
// #define NANODBC_DEPRECATED __declspec(deprecated)
// #else

///
// #define NANODBC_DEPRECATED
// #endif
// #endif

// clang-format off
// 8888888888                                      888    888                        888 888 d8b
// 888                                             888    888                        888 888 Y8P
// 888                                             888    888                        888 888
// 8888888    888d888 888d888 .d88b.  888d888      8888888888  8888b.  88888b.   .d88888 888 888 88888b.   .d88b.
// 888        888P"   888P"  d88""88b 888P"        888    888     "88b 888 "88b d88" 888 888 888 888 "88b d88P"88b
// 888        888     888    888  888 888          888    888 .d888888 888  888 888  888 888 888 888  888 888  888
// 888        888     888    Y88..88P 888          888    888 888  888 888  888 Y88b 888 888 888 888  888 Y88b 888
// 8888888888 888     888     "Y88P"  888          888    888 "Y888888 888  888  "Y88888 888 888 888  888  "Y88888
//                                                                                                             888
//                                                                                                        Y8b d88P
//                                                                                                         "Y88P"
// MARK: Error Handling -
// clang-format on

/** \addtogroup exceptions Exception types
 *  \brief Possible error conditions.
 * 
 *  Specific errors such as \c type_incompatible_error, \c null_access_error, and
 *  \c index_range_error can arise from improper use of the nanodbc library. The general
 *  \c database_error is for all other situations in which the ODBC driver or C API reports an error
 *  condition. The explanatory string for database_error will, if possible, contain a diagnostic
 *  message obtained from \c SQLGetDiagRec().
 *  \{
 <p>
 *  \brief Type incompatible.
 *  @see exceptions */
@Name("nanodbc::type_incompatible_error") public static class TypeIncompatibleError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeIncompatibleError(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeIncompatibleError(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeIncompatibleError position(long position) {
        return (TypeIncompatibleError)super.position(position);
    }
    @Override public TypeIncompatibleError getPointer(long i) {
        return new TypeIncompatibleError((Pointer)this).offsetAddress(i);
    }

    public TypeIncompatibleError() { super((Pointer)null); allocate(); }
    private native void allocate();
    public native @NoException(true) @Cast("const char*") BytePointer what();
}

/** \brief Accessed null data.
 *  @see exceptions */
@Name("nanodbc::null_access_error") public static class NullAccessError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NullAccessError(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public NullAccessError(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public NullAccessError position(long position) {
        return (NullAccessError)super.position(position);
    }
    @Override public NullAccessError getPointer(long i) {
        return new NullAccessError((Pointer)this).offsetAddress(i);
    }

    public NullAccessError() { super((Pointer)null); allocate(); }
    private native void allocate();
    public native @NoException(true) @Cast("const char*") BytePointer what();
}

/** \brief Index out of range.
 *  @see exceptions */
@Name("nanodbc::index_range_error") public static class IndexRangeError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IndexRangeError(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public IndexRangeError(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public IndexRangeError position(long position) {
        return (IndexRangeError)super.position(position);
    }
    @Override public IndexRangeError getPointer(long i) {
        return new IndexRangeError((Pointer)this).offsetAddress(i);
    }

    public IndexRangeError() { super((Pointer)null); allocate(); }
    private native void allocate();
    public native @NoException(true) @Cast("const char*") BytePointer what();
}

/** \brief Programming logic error.
 *  @see exceptions */
@Name("nanodbc::programming_error") public static class ProgrammingError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ProgrammingError(Pointer p) { super(p); }

    public ProgrammingError(@StdString BytePointer info) { super((Pointer)null); allocate(info); }
    private native void allocate(@StdString BytePointer info);
    public ProgrammingError(@StdString String info) { super((Pointer)null); allocate(info); }
    private native void allocate(@StdString String info);
    public native @NoException(true) @Cast("const char*") BytePointer what();
}

/** \brief General database error.
 *  @see exceptions */
@Name("nanodbc::database_error") @NoOffset public static class DatabaseError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DatabaseError(Pointer p) { super(p); }

    /** \brief Creates runtime_error with message about last ODBC error.
     *  @param handle The native ODBC statement or connection handle.
     *  @param handle_type The native ODBC handle type code for the given handle.
     *  @param info Additional info that will be appended to the beginning of the error message. */
    public DatabaseError(Pointer handle, short handle_type, @StdString BytePointer info/*=""*/) { super((Pointer)null); allocate(handle, handle_type, info); }
    private native void allocate(Pointer handle, short handle_type, @StdString BytePointer info/*=""*/);
    public DatabaseError(Pointer handle, short handle_type) { super((Pointer)null); allocate(handle, handle_type); }
    private native void allocate(Pointer handle, short handle_type);
    public DatabaseError(Pointer handle, short handle_type, @StdString String info/*=""*/) { super((Pointer)null); allocate(handle, handle_type, info); }
    private native void allocate(Pointer handle, short handle_type, @StdString String info/*=""*/);
    public native @NoException(true) @Cast("const char*") BytePointer what();
    public native @Name("native") @NoException(true) long _native();
    public native @StdString @NoException(true) BytePointer state();
}

/** \} */

// clang-format off
// 888     888 888    d8b 888 d8b 888    d8b
// 888     888 888    Y8P 888 Y8P 888    Y8P
// 888     888 888        888     888
// 888     888 888888 888 888 888 888888 888  .d88b.  .d8888b
// 888     888 888    888 888 888 888    888 d8P  Y8b 88K
// 888     888 888    888 888 888 888    888 88888888 "Y8888b.
// Y88b. .d88P Y88b.  888 888 888 Y88b.  888 Y8b.          X88
//  "Y88888P"   "Y888 888 888 888  "Y888 888  "Y8888   88888P'
// MARK: Utilities -
// clang-format on

/** \addtogroup utility Utilities
/** \brief Additional nanodbc utility classes and functions.
/**
/** \{
<p>
/** \brief A type for representing date data. */
@Name("nanodbc::date") public static class Date extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Date() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Date(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Date(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Date position(long position) {
        return (Date)super.position(position);
    }
    @Override public Date getPointer(long i) {
        return new Date((Pointer)this).offsetAddress(i);
    }

    /** Year [0-inf). */
    public native short year(); public native Date year(short setter);
    /** Month of the year [1-12]. */
    public native short month(); public native Date month(short setter);
    /** Day of the month [1-31]. */
    public native short day(); public native Date day(short setter);
}

/** \brief A type for representing time data. */
@Name("nanodbc::time") public static class Time extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Time() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Time(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Time(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Time position(long position) {
        return (Time)super.position(position);
    }
    @Override public Time getPointer(long i) {
        return new Time((Pointer)this).offsetAddress(i);
    }

    /** Hours since midnight [0-23]. */
    public native short hour(); public native Time hour(short setter);
    /** Minutes after the hour [0-59]. */
    public native short min(); public native Time min(short setter);
    /** Seconds after the minute. */
    public native short sec(); public native Time sec(short setter);
}

/** \brief A type for representing timestamp data. */
@Name("nanodbc::timestamp") public static class Timestamp extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Timestamp() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Timestamp(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Timestamp(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Timestamp position(long position) {
        return (Timestamp)super.position(position);
    }
    @Override public Timestamp getPointer(long i) {
        return new Timestamp((Pointer)this).offsetAddress(i);
    }

    /** Year [0-inf). */
    public native short year(); public native Timestamp year(short setter);
    /** Month of the year [1-12]. */
    public native short month(); public native Timestamp month(short setter);
    /** Day of the month [1-31]. */
    public native short day(); public native Timestamp day(short setter);
    /** Hours since midnight [0-23]. */
    public native short hour(); public native Timestamp hour(short setter);
    /** Minutes after the hour [0-59]. */
    public native short min(); public native Timestamp min(short setter);
    /** Seconds after the minute. */
    public native short sec(); public native Timestamp sec(short setter);
    /** Fractional seconds. */
    public native int fract(); public native Timestamp fract(int setter);
}

/** \brief A type trait for testing if a type is a std::basic_string compatible with the current
 *  nanodbc configuration */

/** \brief A type trait for testing if a type is a character compatible with the current nanodbc
 *  configuration */


///

/** \}
 <p>
 *  \addtogroup mainc Main classes
 *  \brief Main nanodbc classes.
 * 
 *  \{ */

// clang-format off
// 88888888888                                                  888    d8b
//     888                                                      888    Y8P
//     888                                                      888
//     888  888d888 8888b.  88888b.  .d8888b   8888b.   .d8888b 888888 888  .d88b.  88888b.
//     888  888P"      "88b 888 "88b 88K          "88b d88P"    888    888 d88""88b 888 "88b
//     888  888    .d888888 888  888 "Y8888b. .d888888 888      888    888 888  888 888  888
//     888  888    888  888 888  888      X88 888  888 Y88b.    Y88b.  888 Y88..88P 888  888
//     888  888    "Y888888 888  888  88888P' "Y888888  "Y8888P  "Y888 888  "Y88P"  888  888
// MARK: Transaction -
// clang-format on

/** \brief A resource for managing transaction commits and rollbacks.
/** \attention You will want to use transactions if you are doing batch operations because it will
/**            prevent auto commits from occurring after each individual operation is executed. */
@Name("nanodbc::transaction") @NoOffset public static class Transaction extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Transaction(Pointer p) { super(p); }

    /** \brief Begin a transaction on the given connection object.
     *  \post Operations that modify the database must now be committed before taking effect.
     *  @throws database_error */
    public Transaction(@Const @ByRef Connection conn) { super((Pointer)null); allocate(conn); }
    private native void allocate(@Const @ByRef Connection conn);

    /** Copy constructor. */
    public Transaction(@Const @ByRef Transaction rhs) { super((Pointer)null); allocate(rhs); }
    private native void allocate(@Const @ByRef Transaction rhs);

    /** Move constructor. */

    /** Assignment. */
    public native @ByRef @Name("operator =") Transaction put(@ByVal Transaction rhs);

    /** Member swap. */
    public native @NoException(true) void swap(@ByRef Transaction rhs);

    /** \brief If this transaction has not been committed, will will rollback any modifying ops. */

    /** \brief Commits transaction immediately.
     *  @throws database_error */
    public native void commit();

    /** \brief Marks this transaction for rollback. */
    public native @NoException(true) void rollback();

    /** Returns the connection object. */
    public native @ByRef Connection connection();

    /** Returns the connection object. */

    /** Returns the connection object. */
    public native @ByRef @Name("operator nanodbc::connection&") Connection asConnection();

    /** Returns the connection object. */
}

// clang-format off
//  .d8888b.  888             888                                            888
// d88P  Y88b 888             888                                            888
// Y88b.      888             888                                            888
//  "Y888b.   888888  8888b.  888888 .d88b.  88888b.d88b.   .d88b.  88888b.  888888
//     "Y88b. 888        "88b 888   d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888
//       "888 888    .d888888 888   88888888 888  888  888 88888888 888  888 888
// Y88b  d88P Y88b.  888  888 Y88b. Y8b.     888  888  888 Y8b.     888  888 Y88b.
//  "Y8888P"   "Y888 "Y888888  "Y888 "Y8888  888  888  888  "Y8888  888  888  "Y888
// MARK: Statement -
// clang-format on

/** \brief Represents a statement on the database. */
@Name("nanodbc::statement") @NoOffset public static class Statement extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Statement(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Statement(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Statement position(long position) {
        return (Statement)super.position(position);
    }
    @Override public Statement getPointer(long i) {
        return new Statement((Pointer)this).offsetAddress(i);
    }

    /** \brief Provides support for retrieving output/return parameters.
     *  @see binding */
    /** enum nanodbc::statement::param_direction */
    public static final int
        /** Binding an input parameter. */
        PARAM_IN = 0,
        /** Binding an output parameter. */
        PARAM_OUT = 1,
        /** Binding an input/output parameter. */
        PARAM_INOUT = 2,
        /** Binding a return parameter. */
        PARAM_RETURN = 3;
    /** \brief Creates a new un-prepared statement.
     *  @see execute(), just_execute(), execute_direct(), just_execute_direct(), open(), prepare() */
    public Statement() { super((Pointer)null); allocate(); }
    private native void allocate();

    /** \brief Constructs a statement object and associates it to the given connection.
     *  @param conn The connection to use.
     *  @see open(), prepare() */
    public Statement(@ByRef Connection conn) { super((Pointer)null); allocate(conn); }
    private native void allocate(@ByRef Connection conn);

    /** \brief Constructs and prepares a statement using the given connection and query.
     *  @param conn The connection to use.
     *  @param query The SQL query statement.
     *  @param timeout The number in seconds before query timeout. Default: 0 meaning no timeout.
     *  @see execute(), just_execute(), execute_direct(), just_execute_direct(), open(), prepare() */
    public Statement(@ByRef Connection conn, @StdWString CharPointer query, long timeout/*=0*/) { super((Pointer)null); allocate(conn, query, timeout); }
    private native void allocate(@ByRef Connection conn, @StdWString CharPointer query, long timeout/*=0*/);
    public Statement(@ByRef Connection conn, @StdWString CharPointer query) { super((Pointer)null); allocate(conn, query); }
    private native void allocate(@ByRef Connection conn, @StdWString CharPointer query);
    public Statement(@ByRef Connection conn, @StdWString IntPointer query, long timeout/*=0*/) { super((Pointer)null); allocate(conn, query, timeout); }
    private native void allocate(@ByRef Connection conn, @StdWString IntPointer query, long timeout/*=0*/);
    public Statement(@ByRef Connection conn, @StdWString IntPointer query) { super((Pointer)null); allocate(conn, query); }
    private native void allocate(@ByRef Connection conn, @StdWString IntPointer query);

    /** \brief Copy constructor. */
    public Statement(@Const @ByRef Statement rhs) { super((Pointer)null); allocate(rhs); }
    private native void allocate(@Const @ByRef Statement rhs);

    /** \brief Move constructor. */

    /** \brief Assignment. */
    public native @ByRef @Name("operator =") Statement put(@ByVal Statement rhs);

    /** \brief Member swap. */
    public native @NoException(true) void swap(@ByRef Statement rhs);

    /** \brief Closes the statement.
     *  @see close() */

    /** \brief Creates a statement for the given connection.
     *  @param conn The connection where the statement will be executed.
     *  @throws database_error */
    public native void open(@ByRef Connection conn);

    /** \brief Returns true if connection is open. */
    public native @Cast("bool") boolean open();

    /** \brief Returns true if connected to the database. */
    public native @Cast("bool") boolean connected();

    /** \brief Returns the associated connection object if any. */
    public native @ByRef Connection connection();

    /** \brief Returns the associated connection object if any. */

    /** \brief Returns the native ODBC statement handle. */
    public native Pointer native_statement_handle();

    /** \brief Closes the statement and frees all associated resources. */
    public native @Name("close") void _close();

    /** \brief Cancels execution of the statement.
     *  @throws database_error */
    public native void cancel();

    /** \brief Opens and prepares the given statement to execute on the given connection.
     *  @param conn The connection where the statement will be executed.
     *  @param query The SQL query that will be executed.
     *  @param timeout The number in seconds before query timeout. Default 0 meaning no timeout.
     *  @see open()
     *  @throws database_error */
    public native void prepare(@ByRef Connection conn, @StdWString CharPointer query, long timeout/*=0*/);
    public native void prepare(@ByRef Connection conn, @StdWString CharPointer query);
    public native void prepare(@ByRef Connection conn, @StdWString IntPointer query, long timeout/*=0*/);
    public native void prepare(@ByRef Connection conn, @StdWString IntPointer query);

    /** \brief Prepares the given statement to execute its associated connection.
     *  \note If the statement is not open throws programming_error.
     *  @param query The SQL query that will be executed.
     *  @param timeout The number in seconds before query timeout. Default 0 meaning no timeout.
     *  @see open()
     *  @throws database_error, programming_error */
    public native void prepare(@StdWString CharPointer query, long timeout/*=0*/);
    public native void prepare(@StdWString CharPointer query);
    public native void prepare(@StdWString IntPointer query, long timeout/*=0*/);
    public native void prepare(@StdWString IntPointer query);

    /** \brief Sets the number in seconds before query timeout. Default is 0 indicating no timeout.
     *  @throws database_error */
    public native void timeout(long timeout/*=0*/);
    public native void timeout();

    /** \brief Opens, prepares, and executes the given query directly on the given connection.
     *  @param conn The connection where the statement will be executed.
     *  @param query The SQL query that will be executed.
     *  @param batch_operations Numbers of rows to fetch per rowset, or the number of batch
     *         parameters to process.
     *  @param timeout The number in seconds before query timeout. Default 0 meaning no timeout.
     *  @return A result set object.
     *  \attention You will want to use transactions if you are doing batch operations because it
     *             will prevent auto commits occurring after each individual operation is executed.
     *  @see open(), prepare(), execute(), result, transaction */
    public native @ByVal Result execute_direct(
            @ByRef Connection conn,
            @StdWString CharPointer query,
            long batch_operations/*=1*/,
            long timeout/*=0*/);
    public native @ByVal Result execute_direct(
            @ByRef Connection conn,
            @StdWString CharPointer query);
    public native @ByVal Result execute_direct(
            @ByRef Connection conn,
            @StdWString IntPointer query,
            long batch_operations/*=1*/,
            long timeout/*=0*/);
    public native @ByVal Result execute_direct(
            @ByRef Connection conn,
            @StdWString IntPointer query);

// #if !defined(NANODBC_DISABLE_ASYNC)
// #endif

    /** \brief Execute the previously prepared query now without constructing result object.
     *  @param conn The connection where the statement will be executed.
     *  @param query The SQL query that will be executed.
     *  @param batch_operations Rows to fetch per rowset, or number of batch parameters to process.
     *  @param timeout Seconds before query timeout. Default is 0 indicating no timeout.
     *  @throws database_error
     *  @return A result set object.
     *  \attention You will want to use transactions if you are doing batch operations because it
     *             will prevent auto commits after each individual operation is executed.
     *  @see open(), prepare(), execute(), execute_direct(), result, transaction */
    public native void just_execute_direct(
            @ByRef Connection conn,
            @StdWString CharPointer query,
            long batch_operations/*=1*/,
            long timeout/*=0*/);
    public native void just_execute_direct(
            @ByRef Connection conn,
            @StdWString CharPointer query);
    public native void just_execute_direct(
            @ByRef Connection conn,
            @StdWString IntPointer query,
            long batch_operations/*=1*/,
            long timeout/*=0*/);
    public native void just_execute_direct(
            @ByRef Connection conn,
            @StdWString IntPointer query);

    /** \brief Execute the previously prepared query now.
     *  @param batch_operations Rows to fetch per rowset, or number of batch parameters to process.
     *  @param timeout The number in seconds before query timeout. Default 0 meaning no timeout.
     *  @throws database_error
     *  @return A result set object.
     *  \attention You will want to use transactions if you are doing batch operations because it
     *             will prevent auto commits after each individual operation is executed.
     *  @see open(), prepare(), result, transaction */
    public native @ByVal Result execute(long batch_operations/*=1*/, long timeout/*=0*/);
    public native @ByVal Result execute();

    /** \brief Execute the previously prepared query now without constructing result object.
     *  @param batch_operations Rows to fetch per rowset, or number of batch parameters to process.
     *  @param timeout The number in seconds before query timeout. Default 0 meaning no timeout.
     *  @throws database_error
     *  @return A result set object.
     *  \attention You will want to use transactions if you are doing batch operations because it
     *             will prevent auto commits after each individual operation is executed.
     *  @see open(), prepare(), execute(), result, transaction */
    public native void just_execute(long batch_operations/*=1*/, long timeout/*=0*/);
    public native void just_execute();

    /** \brief Returns the input and output paramters of the specified stored procedure.
     *  @param catalog The catalog name of the procedure.
     *  @param schema Pattern to use for schema names.
     *  @param procedure The name of the procedure.
     *  @param column Pattern to use for column names.
     *  @throws database_error
     *  @return A result set object. */
    public native @ByVal Result procedure_columns(
            @StdWString CharPointer catalog,
            @StdWString CharPointer schema,
            @StdWString CharPointer procedure,
            @StdWString CharPointer column);
    public native @ByVal Result procedure_columns(
            @StdWString IntPointer catalog,
            @StdWString IntPointer schema,
            @StdWString IntPointer procedure,
            @StdWString IntPointer column);

    /** \brief Returns rows affected by the request or -1 if affected rows is not available.
     *  @throws database_error */
    public native long affected_rows();

    /** \brief Returns the number of columns in a result set.
     *  @throws database_error */
    public native short columns();

    /** \brief Resets all currently bound parameters. */
    public native @NoException(true) void reset_parameters();

    /** \brief Returns the number of parameters in the statement.
     *  @throws database_error */
    public native short parameters();

    /** \brief Returns parameter size for indicated parameter placeholder in a prepared statement. */
    
    ///
    ///
    ///
    ///
    public native @Cast("unsigned long") long parameter_size(short param_index);

    /** \addtogroup binding Binding parameters
     *  \brief These functions are used to bind values to ODBC parameters.
     * 
     *  \{
     <p>
     *  \brief Binds given value to given parameter placeholder number in the prepared statement.
     * 
     *  If your prepared SQL query has any ? placeholders, this is how you bind values to them.
     *  Placeholder numbers count from left to right and are 0-indexed.
     * 
     *  It is NOT possible to use these functions for batch operations as number of elements is not
     *  specified here.
     * 
     *  @param param_index Zero-based index of parameter marker (placeholder position).
     *  @param value Value to substitute into placeholder.
     *  @param direction ODBC parameter direction.
     *  @throws database_error */
    
    ///
    ///
    ///
    ///
    public native @Name("bind<short>") void bindShort(short param_index, @Const ShortPointer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(short param_index, @Const ShortPointer value);
    public native @Name("bind<short>") void bindShort(short param_index, @Const ShortBuffer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(short param_index, @Const ShortBuffer value);
    public native @Name("bind<short>") void bindShort(short param_index, @Const short[] value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(short param_index, @Const short[] value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<int>") void bindInt(short param_index, @Const IntPointer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(short param_index, @Const IntPointer value);
    public native @Name("bind<int>") void bindInt(short param_index, @Const IntBuffer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(short param_index, @Const IntBuffer value);
    public native @Name("bind<int>") void bindInt(short param_index, @Const int[] value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(short param_index, @Const int[] value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<long long>") void bindLong(short param_index, @Const LongPointer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(short param_index, @Const LongPointer value);
    public native @Name("bind<long long>") void bindLong(short param_index, @Const LongBuffer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(short param_index, @Const LongBuffer value);
    public native @Name("bind<long long>") void bindLong(short param_index, @Const long[] value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(short param_index, @Const long[] value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<float>") void bindFloat(short param_index, @Const FloatPointer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(short param_index, @Const FloatPointer value);
    public native @Name("bind<float>") void bindFloat(short param_index, @Const FloatBuffer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(short param_index, @Const FloatBuffer value);
    public native @Name("bind<float>") void bindFloat(short param_index, @Const float[] value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(short param_index, @Const float[] value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<double>") void bindDouble(short param_index, @Const DoublePointer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(short param_index, @Const DoublePointer value);
    public native @Name("bind<double>") void bindDouble(short param_index, @Const DoubleBuffer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(short param_index, @Const DoubleBuffer value);
    public native @Name("bind<double>") void bindDouble(short param_index, @Const double[] value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(short param_index, @Const double[] value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<nanodbc::date>") void bindDate(short param_index, @Const Date value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::date>") void bindDate(short param_index, @Const Date value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<nanodbc::time>") void bindTime(short param_index, @Const Time value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::time>") void bindTime(short param_index, @Const Time value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(short param_index, @Const Timestamp value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(short param_index, @Const Timestamp value);
    
    ///
    ///
    ///
    ///
    public native @Name("bind<wchar_t>") void bindString(short param_index, @Cast("const wchar_t*") CharPointer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(short param_index, @Cast("const wchar_t*") CharPointer value);
    public native @Name("bind<wchar_t>") void bindString(short param_index, @Cast("const wchar_t*") IntPointer value, @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(short param_index, @Cast("const wchar_t*") IntPointer value);

    /** \addtogroup bind_multi Binding multiple non-string values
     *  \brief Binds given values to given parameter placeholder number in the prepared statement.
     * 
     *  If your prepared SQL query has any parameter markers, ? (question  mark) placeholders,
     *  this is how you bind values to them.
     *  Parameter markers are numbered using Zero-based index from left to right.
     * 
     *  It is possible to use these functions for batch operations.
     * 
     *  @param param_index Zero-based index of parameter marker (placeholder position).
     *  @param values Values to substitute into placeholder.
     *  @param batch_size The number of values being bound.
     *  @param null_sentry Value which should represent a null value.
     *  @param nulls Flags for values that should be set to a null value.
     *  @param param_direction ODBC parameter direction.
     *  @throws database_error
     * 
     *  \{
     <p>
     *  \brief Binds multiple values.
     *  @see bind_multi */
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") CharPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") CharPointer values,
            @Cast("std::size_t") long batch_size);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") IntPointer values,
            @Cast("std::size_t") long batch_size);

    /** \brief Binds multiple values.
     *  @see bind_multi */
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size,
            @Const ShortPointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size,
            @Const ShortPointer null_sentry);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const ShortBuffer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const ShortBuffer null_sentry);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size,
            @Const short[] null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size,
            @Const short[] null_sentry);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Const IntPointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Const IntPointer null_sentry);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const IntBuffer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const IntBuffer null_sentry);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size,
            @Const int[] null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size,
            @Const int[] null_sentry);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size,
            @Const LongPointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size,
            @Const LongPointer null_sentry);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const LongBuffer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const LongBuffer null_sentry);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size,
            @Const long[] null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size,
            @Const long[] null_sentry);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size,
            @Const FloatPointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size,
            @Const FloatPointer null_sentry);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const FloatBuffer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const FloatBuffer null_sentry);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size,
            @Const float[] null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size,
            @Const float[] null_sentry);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size,
            @Const DoublePointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size,
            @Const DoublePointer null_sentry);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const DoubleBuffer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size,
            @Const DoubleBuffer null_sentry);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size,
            @Const double[] null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size,
            @Const double[] null_sentry);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size,
            @Const Date null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size,
            @Const Date null_sentry);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size,
            @Const Time null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size,
            @Const Time null_sentry);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size,
            @Const Timestamp null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size,
            @Const Timestamp null_sentry);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") CharPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const wchar_t*") CharPointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") CharPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const wchar_t*") CharPointer null_sentry);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const wchar_t*") IntPointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const wchar_t*") IntPointer null_sentry);

    /** \brief Binds multiple values.
     *  @see bind_multi */
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const ShortBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<short>") void bindShort(
            short param_index,
            @Const short[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const IntBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<int>") void bindInt(
            short param_index,
            @Const int[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const LongBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<long long>") void bindLong(
            short param_index,
            @Const long[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const FloatBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<float>") void bindFloat(
            short param_index,
            @Const float[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoublePointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const DoubleBuffer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<double>") void bindDouble(
            short param_index,
            @Const double[] values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::date>") void bindDate(
            short param_index,
            @Const Date values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::time>") void bindTime(
            short param_index,
            @Const Time values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<nanodbc::timestamp>") void bindTimestamp(
            short param_index,
            @Const Timestamp values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") CharPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") CharPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") BoolPointer nulls);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native @Name("bind<wchar_t>") void bindString(
            short param_index,
            @Cast("const wchar_t*") IntPointer values,
            @Cast("std::size_t") long batch_size,
            @Cast("const bool*") boolean[] nulls);

    /** \brief Binds multiple values.
     *  @see bind_multi */
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values);

    /** \brief Binds multiple values.
     *  @see bind_multi */
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const bool*") BoolPointer nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const bool*") BoolPointer nulls);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const bool*") boolean[] nulls,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const bool*") boolean[] nulls);

    /** \brief Binds multiple values.
     *  @see bind_multi */
    
    ///
    ///
    ///
    ///
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const uint8_t*") BytePointer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const uint8_t*") BytePointer null_sentry);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const uint8_t*") ByteBuffer null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const uint8_t*") ByteBuffer null_sentry);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const uint8_t*") byte[] null_sentry,
            @Cast("nanodbc::statement::param_direction") int direction/*=nanodbc::statement::PARAM_IN*/);
    public native void bind(
            short param_index,
            @StdVector UInt8Vector values,
            @Cast("const uint8_t*") byte[] null_sentry);

    /** \}
     <p>
     *  \addtogroup bind_strings Binding multiple string values
     *  \brief Binds given string values to parameter marker in prepared statement.
     * 
     *  If your prepared SQL query has any parameter markers, ? (question  mark) placeholders,
     *  this is how you bind values to them.
     *  Parameter markers are numbered using Zero-based index from left to right.
     * 
     *  It is possible to use these functions for batch operations.
     * 
     *  @param param_index Zero-based index of parameter marker (placeholder position).
     *  @param values Array of values to substitute into parameter placeholders.
     *  @param value_size Maximum length of string value in array.
     *  @param batch_size Number of string values to bind. Otherwise template parameter BatchSize is
     *  taken as the number of values.
     *  @param null_sentry Value which should represent a null value.
     *  @param nulls Flags for values that should be set to a null value.
     *  @param param_direction ODBC parameter direction.
     *  @throws database_error
     * 
     *  \{
     <p>
     *  \brief Binds multiple string values.
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     * 
     *  Size of the values vector indicates number of values to bind.
     *  Longest string in the array determines maximum length of individual value.
     * 
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     *  @see bind_strings */

    /** \brief Binds multiple string values.
     *  @see bind_strings */

    /** \}
     <p>
     *  \brief Binds null values to the parameter placeholder number in the prepared statement.
     * 
     *  If your prepared SQL query has any parameter markers, ? (question  mark) placeholders,
     *  this is how you bind values to them.
     *  Parameter markers are numbered using Zero-based index from left to right.
     * 
     *  It is possible to use this function for batch operations.
     * 
     *  @param param_index Zero-based index of parameter marker (placeholder position).
     *  @param batch_size The number of elements being bound.
     *  @throws database_error */
    
    ///
    ///
    public native void bind_null(short param_index, @Cast("std::size_t") long batch_size/*=1*/);
    public native void bind_null(short param_index);

    /** \}
     <p>
     *  \brief Sets descriptions for parameters in the prepared statement.
     * 
     *  If your prepared SQL query has any parameter markers, ? (question  mark)
     *  placeholders this is how you can describe the SQL type, size and scale
     *  for some or all of the parameters, prior to binding any data to the
     *  parameters.  Calling this method is optional: if a parameter is not
     *  described using a call to this method, then during a bind an attempt is
     *  made to identify it using a call to the ODBC SQLDescribeParam API handle.
     *  Once set, description is re-used for possibly repeated binds
     *  execution and only cleared when the statement is cleared / destroyed.
     *  Parameter markers are numbered using Zero-based index from left to right.
     * 
     *  @param idx Vector of zero-based indices of parameters we are describing.
     *  @param type Vector of (short integer) types.
     *  @param size Vector of (unsigned long) sizes.
     *  @param scale Vector of (short integer) decimal precision / scale.
     *  @throws programming_error */
    public native void describe_parameters(
            @StdVector ShortPointer idx,
            @StdVector ShortPointer type,
            @Cast("unsigned long*") @StdVector CLongPointer size,
            @StdVector ShortPointer scale);
    public native void describe_parameters(
            @StdVector ShortBuffer idx,
            @StdVector ShortBuffer type,
            @Cast("unsigned long*") @StdVector CLongPointer size,
            @StdVector ShortBuffer scale);
    public native void describe_parameters(
            @StdVector short[] idx,
            @StdVector short[] type,
            @Cast("unsigned long*") @StdVector CLongPointer size,
            @StdVector short[] scale);
}

// clang-format off
//  .d8888b.                                               888    d8b
// d88P  Y88b                                              888    Y8P
// 888    888                                              888
// 888         .d88b.  88888b.  88888b.   .d88b.   .d8888b 888888 888  .d88b.  88888b.
// 888        d88""88b 888 "88b 888 "88b d8P  Y8b d88P"    888    888 d88""88b 888 "88b
// 888    888 888  888 888  888 888  888 88888888 888      888    888 888  888 888  888
// Y88b  d88P Y88..88P 888  888 888  888 Y8b.     Y88b.    Y88b.  888 Y88..88P 888  888
//  "Y8888P"   "Y88P"  888  888 888  888  "Y8888   "Y8888P  "Y888 888  "Y88P"  888  888
// MARK: Connection -
// clang-format on

/** \brief Manages and encapsulates ODBC resources such as the connection and environment handles. */
@Name("nanodbc::connection") @NoOffset public static class Connection extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Connection(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Connection(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Connection position(long position) {
        return (Connection)super.position(position);
    }
    @Override public Connection getPointer(long i) {
        return new Connection((Pointer)this).offsetAddress(i);
    }

    /** \brief Create new connection object, initially not connected. */
    public Connection() { super((Pointer)null); allocate(); }
    private native void allocate();

    /** Copy constructor. */
    public Connection(@Const @ByRef Connection rhs) { super((Pointer)null); allocate(rhs); }
    private native void allocate(@Const @ByRef Connection rhs);

    /** Move constructor. */

    /** Assignment. */
    public native @ByRef @Name("operator =") Connection put(@ByVal Connection rhs);

    /** Member swap. */
    
    ///
    ///
    public native @NoException(true) void swap(@ByRef Connection arg0);

    /** \brief Create new connection object and immediately connect to the given data source.
     * 
     *  The function calls ODBC API SQLConnect.
     * 
     *  @param dsn The name of the data source name (DSN).
     *  @param user The username for authenticating to the data source.
     *  @param pass The password for authenticating to the data source.
     *  @param timeout Seconds before connection timeout. Default 0 meaning no timeout.
     *  @throws database_error
     *  @see connected(), connect() */
    
    ///
    ///
    public Connection(@StdWString CharPointer dsn, @StdWString CharPointer user, @StdWString CharPointer pass, long timeout/*=0*/) { super((Pointer)null); allocate(dsn, user, pass, timeout); }
    private native void allocate(@StdWString CharPointer dsn, @StdWString CharPointer user, @StdWString CharPointer pass, long timeout/*=0*/);
    public Connection(@StdWString CharPointer dsn, @StdWString CharPointer user, @StdWString CharPointer pass) { super((Pointer)null); allocate(dsn, user, pass); }
    private native void allocate(@StdWString CharPointer dsn, @StdWString CharPointer user, @StdWString CharPointer pass);
    public Connection(@StdWString IntPointer dsn, @StdWString IntPointer user, @StdWString IntPointer pass, long timeout/*=0*/) { super((Pointer)null); allocate(dsn, user, pass, timeout); }
    private native void allocate(@StdWString IntPointer dsn, @StdWString IntPointer user, @StdWString IntPointer pass, long timeout/*=0*/);
    public Connection(@StdWString IntPointer dsn, @StdWString IntPointer user, @StdWString IntPointer pass) { super((Pointer)null); allocate(dsn, user, pass); }
    private native void allocate(@StdWString IntPointer dsn, @StdWString IntPointer user, @StdWString IntPointer pass);

    /** \brief Create new connection object and immediately connect using the given connection
     *  string.
     * 
     *  The function calls ODBC API SQLDriverConnect.
     * 
     *  @param connection_string The connection string for establishing a connection.
     *  @param timeout Seconds before connection timeout. Default is 0 indicating no timeout.
     *  @throws database_error
     *  @see connected(), connect() */
    
    ///
    public Connection(@StdWString CharPointer connection_string, long timeout/*=0*/) { super((Pointer)null); allocate(connection_string, timeout); }
    private native void allocate(@StdWString CharPointer connection_string, long timeout/*=0*/);
    public Connection(@StdWString CharPointer connection_string) { super((Pointer)null); allocate(connection_string); }
    private native void allocate(@StdWString CharPointer connection_string);
    public Connection(@StdWString IntPointer connection_string, long timeout/*=0*/) { super((Pointer)null); allocate(connection_string, timeout); }
    private native void allocate(@StdWString IntPointer connection_string, long timeout/*=0*/);
    public Connection(@StdWString IntPointer connection_string) { super((Pointer)null); allocate(connection_string); }
    private native void allocate(@StdWString IntPointer connection_string);

    /** \brief Automatically disconnects from the database and frees all associated resources.
     * 
     *  Will not throw even if disconnecting causes some kind of error and raises an exception.
     *  If you explicitly need to know if disconnect() succeeds, call it directly. */

    /** \brief Allocate environment and connection handles.
     * 
     *  Allows on-demand allocation of handles to configure the ODBC environment
     *  and attributes, before database connection is established.
     *  Typically, user does not have to make this call explicitly.
     * 
     *  @throws database_error
     *  @see deallocate() */
    public native @Name("allocate") void _allocate();

    /** \brief Release environment and connection handles.
     *  @see allocate() */
    public native @Name("deallocate") void _deallocate();

    /** \brief Connect to the given data source.
     *  @param dsn The name of the data source.
     *  @param user The username for authenticating to the data source.
     *  @param pass The password for authenticating to the data source.
     *  @param timeout Seconds before connection timeout. Default is 0 indicating no timeout.
     *  @throws database_error
     *  @see connected() */
    public native void connect(@StdWString CharPointer dsn, @StdWString CharPointer user, @StdWString CharPointer pass, long timeout/*=0*/);
    public native void connect(@StdWString CharPointer dsn, @StdWString CharPointer user, @StdWString CharPointer pass);
    public native void connect(@StdWString IntPointer dsn, @StdWString IntPointer user, @StdWString IntPointer pass, long timeout/*=0*/);
    public native void connect(@StdWString IntPointer dsn, @StdWString IntPointer user, @StdWString IntPointer pass);

    /** \brief Connect using the given connection string.
     *  @param connection_string The connection string for establishing a connection.
     *  @param timeout Seconds before connection timeout. Default is 0 indicating no timeout.
     *  @throws database_error
     *  @see connected() */
    public native void connect(@StdWString CharPointer connection_string, long timeout/*=0*/);
    public native void connect(@StdWString CharPointer connection_string);
    public native void connect(@StdWString IntPointer connection_string, long timeout/*=0*/);
    public native void connect(@StdWString IntPointer connection_string);

// #if !defined(NANODBC_DISABLE_ASYNC)
// #endif

    /** \brief Returns true if connected to the database. */
    public native @Cast("bool") boolean connected();

    /** \brief Disconnects from the database, but maintains environment and handle resources. */
    public native void disconnect();

    /** \brief Returns the number of transactions currently held for this connection. */
    public native @Cast("std::size_t") long transactions();

    /** \brief Returns the native ODBC database connection handle. */
    public native Pointer native_dbc_handle();

    /** \brief Returns the native ODBC environment handle. */
    public native Pointer native_env_handle();

    /** \brief Returns information from the ODBC connection as a string or fixed-size value.
     *  The general information about the driver and data source associated
     *  with a connection is obtained using {@code SQLGetInfo} function. */

    /** \brief Returns name of the DBMS product.
     *  Returns the ODBC information type SQL_DBMS_NAME of the DBMS product
     *  accesssed by the driver via the current connection. */
    public native @StdWString CharPointer dbms_name();

    /** \brief Returns version of the DBMS product.
     *  Returns the ODBC information type SQL_DBMS_VER of the DBMS product
     *  accesssed by the driver via the current connection. */
    public native @StdWString CharPointer dbms_version();

    /** \brief Returns the name of the ODBC driver.
     *  @throws database_error */
    public native @StdWString CharPointer driver_name();

    /** \brief Returns the name of the currently connected database.
     *  Returns the current SQL_DATABASE_NAME information value associated with the connection. */
    public native @StdWString CharPointer database_name();

    /** \brief Returns the name of the current catalog.
     *  Returns the current setting of the connection attribute SQL_ATTR_CURRENT_CATALOG. */
    public native @StdWString CharPointer catalog_name();
}

// clang-format off
// 8888888b.                            888 888
// 888   Y88b                           888 888
// 888    888                           888 888
// 888   d88P .d88b.  .d8888b  888  888 888 888888
// 8888888P" d8P  Y8b 88K      888  888 888 888
// 888 T88b  88888888 "Y8888b. 888  888 888 888
// 888  T88b Y8b.          X88 Y88b 888 888 Y88b.
// 888   T88b "Y8888   88888P'  "Y88888 888  "Y888
// MARK: Result -
// clang-format on

/** \brief A resource for managing result sets from statement execution.
 * 
 *  @see statement::execute(), statement::execute_direct()
 *  \note result objects may be copied, however all copies will refer to the same result set. */
@Name("nanodbc::result") @NoOffset public static class Result extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Result(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Result(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Result position(long position) {
        return (Result)super.position(position);
    }
    @Override public Result getPointer(long i) {
        return new Result((Pointer)this).offsetAddress(i);
    }

    /** \brief Empty result set. */
    public Result() { super((Pointer)null); allocate(); }
    private native void allocate();

    /** \brief Free result set. */

    /** \brief Copy constructor. */
    public Result(@Const @ByRef Result rhs) { super((Pointer)null); allocate(rhs); }
    private native void allocate(@Const @ByRef Result rhs);

    /** \brief Move constructor. */

    /** \brief Assignment. */
    public native @ByRef @Name("operator =") Result put(@ByVal Result rhs);

    /** \brief Member swap. */
    public native @NoException(true) void swap(@ByRef Result rhs);

    /** \brief Returns the native ODBC statement handle. */
    public native Pointer native_statement_handle();

    /** \brief The rowset size for this result set. */
    public native @NoException(true) long rowset_size();

    /** \brief Number of affected rows by the request or -1 if the affected rows is not available.
     *  @throws database_error */
    public native long affected_rows();

    /** \brief Reports if number of affected rows is available.
     *  @return true if number of affected rows is known, regardless of the value;
     *  false if the number is not available.
     *  @throws database_error
     *  <pre>{@code {.cpp}
     *  assert(r.has_affected_rows() == (r.affected_rows() >= 0));
     *  }</pre> */
    public native @Cast("bool") boolean has_affected_rows();

    /** \brief Rows in the current rowset or 0 if the number of rows is not available. */
    public native @NoException(true) long rows();

    /** \brief Returns the number of columns in a result set.
     *  @throws database_error */
    public native short columns();

    /** \brief Fetches the first row in the current result set.
     *  @return true if there are more results or false otherwise.
     *  @throws database_error */
    public native @Cast("bool") boolean first();

    /** \brief Fetches the last row in the current result set.
     *  @return true if there are more results or false otherwise.
     *  @throws database_error */
    public native @Cast("bool") boolean last();

    /** \brief Fetches the next row in the current result set.
     *  @return true if there are more results or false otherwise.
     *  @throws database_error */
    public native @Cast("bool") boolean next();

// #if !defined(NANODBC_DISABLE_ASYNC)
// #endif

    /** \brief Fetches the prior row in the current result set.
     *  @return true if there are more results or false otherwise.
     *  @throws database_error */
    public native @Cast("bool") boolean prior();

    /** \brief Moves to and fetches the specified row in the current result set.
     *  @return true if there are results or false otherwise.
     *  @throws database_error */
    public native @Cast("bool") boolean move(long row);

    /** \brief Skips a number of rows and then fetches the resulting row in the current result set.
     *  @return true if there are results or false otherwise.
     *  @throws database_error */
    public native @Cast("bool") boolean skip(long rows);

    /** \brief Returns the row position in the current result set. */
    public native @Cast("unsigned long") @Name("position") long _position();

    /** \brief Returns true if there are no more results in the current result set. */
    
    ///
    public native @Cast("bool") @NoException(true) boolean at_end();

    /** \brief Unbind data buffers for all columns in the result set.
     * 
     *  Wraps unbind(short column)
     *  @throws index_range_error, database_error */
    
    ///
    ///
    public native void unbind();

    /** \brief Unbind data buffers for specific columns in the result set.
     * 
     *  Wraps unbind(short column)
     * 
     *  @param column_name string Name of column we wish to unbind.
     *  @throws index_range_error, database_error */
    
    ///
    ///
    public native void unbind(@StdWString CharPointer column_name);
    public native void unbind(@StdWString IntPointer column_name);

    /** \brief Unbind data buffers for specific columns in the result set.
     * 
     *  When a result is constructed, in order to optimize data retrieval,
     *  we automatically try to bind buffers, except for columns that contain
     *  long/blob data types.  This method gives the caller the option to unbind
     *  a specific buffer.  Subsequently, during calls to get(), if there is no
     *  bound data buffer, we will attempt to retrieve the data using a call
     *  SQLGetData; this is similar to the route taken for columns hosting long
     *  or bloby data types.  This is suboptimal from efficiency perspective,
     *  however may be necessary of the driver we are communicating with does
     *  not support out-of-order retrieval of long data.
     * 
     *  @param column short Zero-based index of column we wish to unbind.
     *  @throws index_range_error, database_error */
    
    ///
    public native void unbind(short column);

    /** \brief Gets data from the given column of the current rowset.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column position.
     *  @param result The column's value will be written to this parameter.
     *  @throws database_error, index_range_error, type_incompatible_error, null_access_error */

    /** \brief Gets data from the given column of the current rowset.
     * 
     *  If the data is null, fallback is returned instead.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column position.
     *  @param fallback if value is null, return fallback instead.
     *  @param result The column's value will be written to this parameter.
     *  @throws database_error, index_range_error, type_incompatible_error */

    /** \brief Gets data from the given column by name of the current rowset.
     * 
     *  @param column_name column's name.
     *  @param result The column's value will be written to this parameter.
     *  @throws database_error, index_range_error, type_incompatible_error, null_access_error */

    /** \brief Gets data from the given column by name of the current rowset.
     * 
     *  If the data is null, fallback is returned instead.
     * 
     *  @param column_name column's name.
     *  @param fallback if value is null, return fallback instead.
     *  @param result The column's value will be written to this parameter.
     *  @throws database_error, index_range_error, type_incompatible_error */

    /** \brief Gets data from the given column of the current rowset.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column position.
     *  @throws database_error, index_range_error, type_incompatible_error, null_access_error */
    
    ///
    ///
    public native @Name("get<short>") short getShort(short column);
    
    ///
    ///
    public native @Name("get<int>") int getInt(short column);
    
    ///
    ///
    public native @Name("get<long long>") long getLong(short column);
    
    ///
    ///
    public native @Name("get<float>") float getFloat(short column);
    
    ///
    ///
    public native @Name("get<double>") double getDouble(short column);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::date>") Date getDate(short column);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::time>") Time getTime(short column);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::timestamp>") Timestamp getTimestamp(short column);
    
    ///
    ///
    public native @StdWString @Name("get<std::wstring>") CharPointer getString(short column);

    /** \brief Gets data from the given column of the current rowset.
     * 
     *  If the data is null, fallback is returned instead.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column position.
     *  @param fallback if value is null, return fallback instead.
     *  @throws database_error, index_range_error, type_incompatible_error */
    
    ///
    public native @Name("get<short>") short getShort(short column, short fallback);
    
    ///
    public native @Name("get<int>") int getInt(short column, int fallback);
    
    ///
    public native @Name("get<long long>") long getLong(short column, long fallback);
    
    ///
    public native @Name("get<float>") float getFloat(short column, float fallback);
    
    ///
    public native @Name("get<double>") double getDouble(short column, double fallback);
    
    ///
    public native @ByVal @Name("get<nanodbc::date>") Date getDate(short column, @Const @ByRef Date fallback);
    
    ///
    public native @ByVal @Name("get<nanodbc::time>") Time getTime(short column, @Const @ByRef Time fallback);
    
    ///
    public native @ByVal @Name("get<nanodbc::timestamp>") Timestamp getTimestamp(short column, @Const @ByRef Timestamp fallback);
    
    ///
    public native @StdWString @Name("get<std::wstring>") CharPointer getString(short column, @StdWString CharPointer fallback);
    public native @StdWString @Name("get<std::wstring>") IntPointer getString(short column, @StdWString IntPointer fallback);

    /** \brief Gets data from the given column by name of the current rowset.
     * 
     *  @param column_name column's name.
     *  @throws database_error, index_range_error, type_incompatible_error, null_access_error */
    
    ///
    ///
    public native @Name("get<short>") short getShort(@StdWString CharPointer column_name);
    public native @Name("get<short>") short getShort(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @Name("get<int>") int getInt(@StdWString CharPointer column_name);
    public native @Name("get<int>") int getInt(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @Name("get<long long>") long getLong(@StdWString CharPointer column_name);
    public native @Name("get<long long>") long getLong(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @Name("get<float>") float getFloat(@StdWString CharPointer column_name);
    public native @Name("get<float>") float getFloat(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @Name("get<double>") double getDouble(@StdWString CharPointer column_name);
    public native @Name("get<double>") double getDouble(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::date>") Date getDate(@StdWString CharPointer column_name);
    public native @ByVal @Name("get<nanodbc::date>") Date getDate(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::time>") Time getTime(@StdWString CharPointer column_name);
    public native @ByVal @Name("get<nanodbc::time>") Time getTime(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::timestamp>") Timestamp getTimestamp(@StdWString CharPointer column_name);
    public native @ByVal @Name("get<nanodbc::timestamp>") Timestamp getTimestamp(@StdWString IntPointer column_name);
    
    ///
    ///
    public native @StdWString @Name("get<std::wstring>") CharPointer getString(@StdWString CharPointer column_name);
    public native @StdWString @Name("get<std::wstring>") IntPointer getString(@StdWString IntPointer column_name);

    /** \brief Gets data from the given column by name of the current rowset.
     * 
     *  If the data is null, fallback is returned instead.
     * 
     *  @param column_name column's name.
     *  @param fallback if value is null, return fallback instead.
     *  @throws database_error, index_range_error, type_incompatible_error */
    
    ///
    ///
    public native @Name("get<short>") short getShort(@StdWString CharPointer column_name, short fallback);
    public native @Name("get<short>") short getShort(@StdWString IntPointer column_name, short fallback);
    
    ///
    ///
    public native @Name("get<int>") int getInt(@StdWString CharPointer column_name, int fallback);
    public native @Name("get<int>") int getInt(@StdWString IntPointer column_name, int fallback);
    
    ///
    ///
    public native @Name("get<long long>") long getLong(@StdWString CharPointer column_name, long fallback);
    public native @Name("get<long long>") long getLong(@StdWString IntPointer column_name, long fallback);
    
    ///
    ///
    public native @Name("get<float>") float getFloat(@StdWString CharPointer column_name, float fallback);
    public native @Name("get<float>") float getFloat(@StdWString IntPointer column_name, float fallback);
    
    ///
    ///
    public native @Name("get<double>") double getDouble(@StdWString CharPointer column_name, double fallback);
    public native @Name("get<double>") double getDouble(@StdWString IntPointer column_name, double fallback);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::date>") Date getDate(@StdWString CharPointer column_name, @Const @ByRef Date fallback);
    public native @ByVal @Name("get<nanodbc::date>") Date getDate(@StdWString IntPointer column_name, @Const @ByRef Date fallback);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::time>") Time getTime(@StdWString CharPointer column_name, @Const @ByRef Time fallback);
    public native @ByVal @Name("get<nanodbc::time>") Time getTime(@StdWString IntPointer column_name, @Const @ByRef Time fallback);
    
    ///
    ///
    public native @ByVal @Name("get<nanodbc::timestamp>") Timestamp getTimestamp(@StdWString CharPointer column_name, @Const @ByRef Timestamp fallback);
    public native @ByVal @Name("get<nanodbc::timestamp>") Timestamp getTimestamp(@StdWString IntPointer column_name, @Const @ByRef Timestamp fallback);
    
    ///
    ///
    public native @StdWString @Name("get<std::wstring>") CharPointer getString(@StdWString CharPointer column_name, @StdWString CharPointer fallback);
    public native @StdWString @Name("get<std::wstring>") IntPointer getString(@StdWString IntPointer column_name, @StdWString IntPointer fallback);

    /** \brief Returns true if and only if the given column of the current rowset is null.
     * 
     *  There is a bug/limitation in ODBC drivers for SQL Server (and possibly others)
     *  which causes SQLBindCol() to never write SQL_NOT_NULL to the length/indicator
     *  buffer unless you also bind the data column. nanodbc's is_null() will return
     *  correct values for (n)varchar(max) columns when you ensure that SQLGetData()
     *  has been called for that column (i.e. after get() or get_ref() is called).
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @see get(), get_ref()
     *  @param column position.
     *  @throws database_error, index_range_error */
    
    ///
    public native @Cast("bool") boolean is_null(short column);

    /** \brief Returns true if and only if the given column by name of the current rowset is null.
     * 
     *  See is_null(short column) for details on a bug/limitation of some ODBC drivers.
     *  @see is_null()
     *  @param column_name column's name.
     *  @throws database_error, index_range_error */
    
    ///
    ///
    public native @Cast("bool") boolean is_null(@StdWString CharPointer column_name);
    public native @Cast("bool") boolean is_null(@StdWString IntPointer column_name);

    /** \brief Returns true if we have bound a buffer to the given column.
     * 
     *  Generically, nanodbc will greedily bind buffers to columns in the result
     *  set.  However, we have also given the user the ability to unbind buffers
     *  via unbind() forcing nanodbc to retrieve data via SQLGetData.  This
     *  method returns true if there is a buffer bound to the column.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column short position.
     *  @throws index_range_error */
    
    ///
    public native @Cast("bool") boolean is_bound(short column);

    /** \brief Returns true if we have bound a buffer to the given column.
     * 
     *  See is_bound(short column) for details.
     *  @see is_bound()
     *  @param column_name column's name.
     *  @throws index_range_error */
    
    ///
    public native @Cast("bool") boolean is_bound(@StdWString CharPointer column_name);
    public native @Cast("bool") boolean is_bound(@StdWString IntPointer column_name);

    /** \brief Returns the column number of the specified column name.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column_name column's name.
     *  @throws index_range_error */
    
    ///
    public native short column(@StdWString CharPointer column_name);
    public native short column(@StdWString IntPointer column_name);

    /** \brief Returns the name of the specified column.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column position.
     *  @throws index_range_error */
    
    ///
    public native @StdWString CharPointer column_name(short column);

    /** \brief Returns the size of the specified column.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column position.
     *  @throws index_range_error */
    public native long column_size(short column);

    /** \brief Returns the size of the specified column by name. */
    
    ///
    ///
    public native long column_size(@StdWString CharPointer column_name);
    public native long column_size(@StdWString IntPointer column_name);

    /** \brief Returns the number of decimal digits of the specified column.
     * 
     *  Applies to exact numeric types (scale), datetime and interval types (prcision).
     *  If the number cannot be determined or is not applicable, drivers typically return 0.
     * 
     *  Columns are numbered from left to right and 0-indexed.
     *  @param column position.
     *  @throws index_range_error */
    public native int column_decimal_digits(short column);

    /** \brief Returns the number of decimal digits of the specified column by name. */
    public native int column_decimal_digits(@StdWString CharPointer column_name);
    public native int column_decimal_digits(@StdWString IntPointer column_name);

    /** \brief Returns a identifying integer value representing the SQL type of this column. */
    public native int column_datatype(short column);

    /** \brief Returns a identifying integer value representing the SQL type of this column by name. */
    
    ///
    public native int column_datatype(@StdWString CharPointer column_name);
    public native int column_datatype(@StdWString IntPointer column_name);

    /** \brief Returns data source dependent data type name of this column.
     * 
     *  The function calls SQLCoLAttribute with the field attribute SQL_DESC_TYPE_NAME to
     *  obtain the data type name.
     *  If the type is unknown, an empty string is returned.
     *  \note Unlike other column metadata functions (eg. column_datatype()),
     *  this function cost is an extra ODBC API call. */
    
    ///
    public native @StdWString CharPointer column_datatype_name(short column);

    /** \brief Returns data source dependent data type name of this column by name.
     * 
     *  The function calls SQLCoLAttribute with the field attribute SQL_DESC_TYPE_NAME to
     *  obtain the data type name.
     *  If the type is unknown, an empty string is returned.
     *  \note Unlike other column metadata functions (eg. column_datatype()),
     *  this function cost is an extra ODBC API call. */
    public native @StdWString CharPointer column_datatype_name(@StdWString CharPointer column_name);
    public native @StdWString IntPointer column_datatype_name(@StdWString IntPointer column_name);

    /** \brief Returns a identifying integer value representing the C type of this column. */
    public native int column_c_datatype(short column);

    /** \brief Returns a identifying integer value representing the C type of this column by name. */
    public native int column_c_datatype(@StdWString CharPointer column_name);
    public native int column_c_datatype(@StdWString IntPointer column_name);

    /** \brief Returns the next result, e.g. when stored procedure returns multiple result sets. */
    public native @Cast("bool") boolean next_result();

    /** \brief If and only if result object is valid, returns true. */
    public native @Cast("bool") @Name("operator bool") boolean asBoolean();
}

/** \brief Single pass input iterator that accesses successive rows in the attached result set. */
@Name("nanodbc::result_iterator") @NoOffset public static class ResultIterator extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ResultIterator(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ResultIterator(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ResultIterator position(long position) {
        return (ResultIterator)super.position(position);
    }
    @Override public ResultIterator getPointer(long i) {
        return new ResultIterator((Pointer)this).offsetAddress(i);
    }

    /** Category of iterator. */
    /** Values returned by iterator access. */
    /** Pointer to iteration values. */
    /** Reference to iteration values. */
    /** Iterator difference. */

    /** Default iterator; an empty result set. */
    public ResultIterator() { super((Pointer)null); allocate(); }
    private native void allocate();

    /** Create result iterator for a given result set. */
    public ResultIterator(@ByRef Result r) { super((Pointer)null); allocate(r); }
    private native void allocate(@ByRef Result r);

    /** Dereference. */
    public native @ByRef @ByVal @Name("operator *") Result multiply();

    /** Access through dereference. */
    public native @Cast("nanodbc::result_iterator::pointer") @Name("operator ->") Result access();

    /** Iteration. */
    public native @ByRef @Name("operator ++") ResultIterator increment();

    /** Iteration. */
    public native @ByVal @Name("operator ++") ResultIterator increment(int arg0);

    /** Iterators are equal if they a tied to the same native statemnt handle, or both empty. */
    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef ResultIterator rhs);

    /** Iterators are not equal if they have different native statemnt handles. */
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef ResultIterator rhs);
}

/** \brief Returns an iterator to the beginning of the given result set. */

///
@Namespace("nanodbc") public static native @ByVal ResultIterator begin(@ByRef Result r);

/** \brief Returns an iterator to the end of a result set.
 * 
 *  The default-constructed {@code nanodbc::result_iterator} is known as the end-of-result iterator.
 *  When a valid {@code nanodbc::result_iterator} reaches the end of the underlying result set,
 *  it becomes equal to the end-of-result iterator.
 *  Dereferencing or incrementing it further is undefined. */

///
@Namespace("nanodbc") public static native @ByVal ResultIterator end(@ByRef Result arg0);

// clang-format off
//
//  .d8888b.           888             888
// d88P  Y88b          888             888
// 888    888          888             888
// 888         8888b.  888888  8888b.  888  .d88b.   .d88b.
// 888            "88b 888        "88b 888 d88""88b d88P"88b
// 888    888 .d888888 888    .d888888 888 888  888 888  888
// Y88b  d88P 888  888 Y88b.  888  888 888 Y88..88P Y88b 888
//  "Y8888P"  "Y888888  "Y888 "Y888888 888  "Y88P"   "Y88888
//                                                      888
//                                                 Y8b d88P
//                                                  "Y88P"
// MARK: Catalog -
// clang-format on

/** \brief A resource for get catalog information from connected data source.
 * 
 *  Queries are performed using the Catalog Functions in ODBC.
 *  All provided operations are convenient wrappers around the ODBC API
 *  The original ODBC behaviour should not be affected by any added processing. */
@Name("nanodbc::catalog") @NoOffset public static class Catalog extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Catalog(Pointer p) { super(p); }

    /** \brief Result set for a list of tables in the data source. */
    @NoOffset public static class tables extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public tables(Pointer p) { super(p); }
    
        /** Move to the next result in the result set. */
        public native @Cast("bool") boolean next();
        /** Fetch table catalog. */
        public native @StdWString CharPointer table_catalog();
        /** Fetch table schema. */
        public native @StdWString CharPointer table_schema();
        /** Fetch table name. */
        public native @StdWString CharPointer table_name();
        /** Fetch table type. */
        public native @StdWString CharPointer table_type();
        /** Fetch table remarks. */
        public native @StdWString CharPointer table_remarks();
    }

    /** \brief Result set for a list of columns in one or more tables. */
    @NoOffset public static class columns extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public columns(Pointer p) { super(p); }
    
        /** Move to the next result in the result set. */
        public native @Cast("bool") boolean next();
        /** Fetch table catalog. */
        public native @StdWString CharPointer table_catalog();
        /** Fetch table schema. */
        public native @StdWString CharPointer table_schema();
        /** Fetch table name. */
        public native @StdWString CharPointer table_name();
        /** Fetch column name. */
        public native @StdWString CharPointer column_name();
        /** Fetch column data type. */
        public native short data_type();
        /** Fetch column type name. */
        public native @StdWString CharPointer type_name();
        /** Fetch column size. */
        public native long column_size();
        /** Fetch buffer length. */
        public native long buffer_length();
        /** Fetch decimal digits. */
        public native short decimal_digits();
        /** Fetch numeric precission. */
        public native short numeric_precision_radix();
        /** True iff column is nullable. */
        public native short nullable();
        /** Fetch column remarks. */
        public native @StdWString CharPointer remarks();
        /** Fetch column's default. */
        public native @StdWString CharPointer column_default();
        /** Fetch column's SQL data type. */
        public native short sql_data_type();
        /** Fetch datetime subtype of column. */
        public native short sql_datetime_subtype();
        /** Fetch char octet length. */
        public native long char_octet_length();

        /** \brief Ordinal position of the column in the table.
         *  The first column in the table is number 1.
         *  Returns ORDINAL_POSITION column value in result set returned by SQLColumns. */
        
        ///
        public native long ordinal_position();

        /** \brief Fetch column is-nullable information.
         * 
         *  \note MSDN: This column returns a zero-length string if nullability is unknown.
         *        ISO rules are followed to determine nullability.
         *        An ISO SQL-compliant DBMS cannot return an empty string. */
        public native @StdWString CharPointer is_nullable();
    }

    /** \brief Result set for a list of columns that compose the primary key of a single table. */
    @NoOffset public static class primary_keys extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public primary_keys(Pointer p) { super(p); }
    
        /** Move to the next result in the result set. */
        public native @Cast("bool") boolean next();
        /** Fetch table catalog. */
        public native @StdWString CharPointer table_catalog();
        /** Fetch table schema. */
        public native @StdWString CharPointer table_schema();
        /** Fetch table name. */
        public native @StdWString CharPointer table_name();
        /** Fetch column name. */
        public native @StdWString CharPointer column_name();

        /** \brief Column sequence number in the key (starting with 1).
         *  Returns valye of KEY_SEQ column in result set returned by SQLPrimaryKeys. */
        public native short column_number();

        /** \brief Primary key name.
         *  NULL if not applicable to the data source.
         *  Returns valye of PK_NAME column in result set returned by SQLPrimaryKeys. */
        public native @StdWString CharPointer primary_key_name();
    }

    /** \brief Result set for a list of tables and the privileges associated with each table. */
    @NoOffset public static class table_privileges extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public table_privileges(Pointer p) { super(p); }
    
        /** Move to the next result in the result set */
        public native @Cast("bool") boolean next();
        /** Fetch table catalog. */
        public native @StdWString CharPointer table_catalog();
        /** Fetch table schema. */
        public native @StdWString CharPointer table_schema();
        /** Fetch table name. */
        public native @StdWString CharPointer table_name();
        /** Fetch name of user who granted the privilege. */
        public native @StdWString CharPointer grantor();
        /** Fetch name of user whom the privilege was granted. */
        public native @StdWString CharPointer grantee();
        /** Fetch the table privilege. */
        public native @StdWString CharPointer privilege();
        /** Fetch indicator whether the grantee is permitted to grant the privilege to other users. */
        public native @StdWString CharPointer is_grantable();
    }

    /** \brief Result set for a list of procedures in the data source. */
    @NoOffset public static class procedures extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public procedures(Pointer p) { super(p); }
    
        /** Move to the next result in the result set. */
        public native @Cast("bool") boolean next();
        /** Fetch procedure catalog. */
        public native @StdWString CharPointer procedure_catalog();
        /** Fetch procedure schema. */
        public native @StdWString CharPointer procedure_schema();
        /** Fetch procedure name. */
        public native @StdWString CharPointer procedure_name();
        /** Fetch procedure remarks. */
        public native @StdWString CharPointer procedure_remarks();
        /** Fetch procedure type. */
        public native short procedure_type();
    }

    /** \brief Result set for a list of procedures in the data source. */
    @NoOffset public static class procedure_columns extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public procedure_columns(Pointer p) { super(p); }
    
        /** Move to the next result in the result set. */
        public native @Cast("bool") boolean next();
        /** Fetch procedure catalog. */
        public native @StdWString CharPointer procedure_catalog();
        /** Fetch procedure schema. */
        public native @StdWString CharPointer procedure_schema();
        /** Fetch procedure name. */
        public native @StdWString CharPointer procedure_name();
        /** Fetch column name. */
        public native @StdWString CharPointer column_name();
        /** Fetch column type. */
        public native short column_type();
        /** Fetch column data type. */
        public native short data_type();
        /** Fetch column type name. */
        public native @StdWString CharPointer type_name();
        /** Fetch column size. */
        public native long column_size();
        /** Fetch buffer length. */
        public native long buffer_length();
        /** Fetch decimal digits. */
        public native short decimal_digits();
        /** Fetch numeric precission. */
        public native short numeric_precision_radix();
        /** True iff column is nullable. */
        public native short nullable();
        /** Fetch column remarks. */
        public native @StdWString CharPointer remarks();
        /** Fetch column's default. */
        public native @StdWString CharPointer column_default();
        /** Fetch column's SQL data type. */
        public native short sql_data_type();
        /** Fetch datetime subtype of column. */
        public native short sql_datetime_subtype();
        /** Fetch char octet length. */
        public native long char_octet_length();

        /** \brief Ordinal position of the column in the table.
         *  The first column in the table is number 1.
         *  Returns ORDINAL_POSITION column value in result set returned by SQLColumns. */
        
        ///
        public native long ordinal_position();

        /** \brief Fetch column is-nullable information.
         * 
         *  \note MSDN: This column returns a zero-length string if nullability is unknown.
         *        ISO rules are followed to determine nullability.
         *        An ISO SQL-compliant DBMS cannot return an empty string. */
        public native @StdWString CharPointer is_nullable();
    }

    /** \brief Creates catalog operating on database accessible through the specified connection. */
    
    ///
    ///
    public Catalog(@ByRef Connection conn) { super((Pointer)null); allocate(conn); }
    private native void allocate(@ByRef Connection conn);

    /** \brief Creates result set with catalogs, schemas, tables, or table types.
     * 
     *  Tables information is obtained by executing {@code SQLTable} function within
     *  scope of the connected database accessible with the specified connection.
     *  Since this function is implemented in terms of the {@code SQLTable}s, it returns
     *  result set ordered by TABLE_TYPE, TABLE_CAT, TABLE_SCHEM, and TABLE_NAME.
     * 
     *  All arguments are treated as the Pattern Value Arguments.
     *  Empty string argument is equivalent to passing the search pattern '%'. */
    
    ///
    ///
    public native @ByVal tables find_tables(
            @StdWString CharPointer table/*=nanodbc::string()*/,
            @StdWString CharPointer type/*=nanodbc::string()*/,
            @StdWString CharPointer schema/*=nanodbc::string()*/,
            @StdWString CharPointer catalog/*=nanodbc::string()*/);
    public native @ByVal tables find_tables();
    public native @ByVal tables find_tables(
            @StdWString IntPointer table/*=nanodbc::string()*/,
            @StdWString IntPointer type/*=nanodbc::string()*/,
            @StdWString IntPointer schema/*=nanodbc::string()*/,
            @StdWString IntPointer catalog/*=nanodbc::string()*/);

    /** \brief Creates result set with tables and the privileges associated with each table.
     *  Tables information is obtained by executing {@code SQLTablePrivileges} function within
     *  scope of the connected database accessible with the specified connection.
     *  Since this function is implemented in terms of the {@code SQLTablePrivileges}s, it returns
     *  result set ordered by TABLE_CAT, TABLE_SCHEM, TABLE_NAME, PRIVILEGE, and GRANTEE.
     * 
     *  @param catalog The table catalog. It cannot contain a string search pattern.
     *  @param schema String search pattern for schema names, treated as the Pattern Value
     *  Arguments.
     *  @param table String search pattern for table names, treated as the Pattern Value Arguments.
     * 
     *  \note Due to the fact catalog cannot is not the Pattern Value Argument,
     *        order of parameters is different than in the other catalog look-up functions. */
    
    ///
    ///
    public native @ByVal table_privileges find_table_privileges(
            @StdWString CharPointer catalog,
            @StdWString CharPointer table/*=nanodbc::string()*/,
            @StdWString CharPointer schema/*=nanodbc::string()*/);
    public native @ByVal table_privileges find_table_privileges(
            @StdWString CharPointer catalog);
    public native @ByVal table_privileges find_table_privileges(
            @StdWString IntPointer catalog,
            @StdWString IntPointer table/*=nanodbc::string()*/,
            @StdWString IntPointer schema/*=nanodbc::string()*/);
    public native @ByVal table_privileges find_table_privileges(
            @StdWString IntPointer catalog);

    /** \brief Creates result set with columns in one or more tables.
     * 
     *  Columns information is obtained by executing {@code SQLColumns} function within
     *  scope of the connected database accessible with the specified connection.
     *  Since this function is implemented in terms of the {@code SQLColumns}, it returns
     *  result set ordered by TABLE_CAT, TABLE_SCHEM, TABLE_NAME, and ORDINAL_POSITION.
     * 
     *  All arguments are treated as the Pattern Value Arguments.
     *  Empty string argument is equivalent to passing the search pattern '%'. */
    
    ///
    ///
    public native @ByVal columns find_columns(
            @StdWString CharPointer column/*=nanodbc::string()*/,
            @StdWString CharPointer table/*=nanodbc::string()*/,
            @StdWString CharPointer schema/*=nanodbc::string()*/,
            @StdWString CharPointer catalog/*=nanodbc::string()*/);
    public native @ByVal columns find_columns();
    public native @ByVal columns find_columns(
            @StdWString IntPointer column/*=nanodbc::string()*/,
            @StdWString IntPointer table/*=nanodbc::string()*/,
            @StdWString IntPointer schema/*=nanodbc::string()*/,
            @StdWString IntPointer catalog/*=nanodbc::string()*/);

    /** \brief Creates result set with columns that compose the primary key of a single table.
     * 
     *  Returns result set with column names that make up the primary key for a table.
     *  The primary key information is obtained by executing {@code SQLPrimaryKey} function within
     *  scope of the connected database accessible with the specified connection.
     * 
     *  All arguments are treated as the Pattern Value Arguments.
     *  Empty string argument is equivalent to passing the search pattern '%'. */
    
    ///
    ///
    public native @ByVal primary_keys find_primary_keys(
            @StdWString CharPointer table,
            @StdWString CharPointer schema/*=nanodbc::string()*/,
            @StdWString CharPointer catalog/*=nanodbc::string()*/);
    public native @ByVal primary_keys find_primary_keys(
            @StdWString CharPointer table);
    public native @ByVal primary_keys find_primary_keys(
            @StdWString IntPointer table,
            @StdWString IntPointer schema/*=nanodbc::string()*/,
            @StdWString IntPointer catalog/*=nanodbc::string()*/);
    public native @ByVal primary_keys find_primary_keys(
            @StdWString IntPointer table);

    /** \brief Creates result set with catalog, schema, procedure, and procedure types.
     * 
     *  Procedure information is obtained by executing {@code SQLProcedures} function within
     *  scope of the connected database accessible with the specified connection.
     *  Since this function is implemented in terms of the {@code SQLProcedures}s, it returns
     *  result set ordered by PROCEDURE_CAT, PROCEDUORE_SCHEM, and PROCEDURE_NAME.
     * 
     *  All arguments are treated as the Pattern Value Arguments.
     *  Empty string argument is equivalent to passing the search pattern '%'. */

    
    ///
    ///
    public native @ByVal procedures find_procedures(
            @StdWString CharPointer procedure/*=nanodbc::string()*/,
            @StdWString CharPointer schema/*=nanodbc::string()*/,
            @StdWString CharPointer catalog/*=nanodbc::string()*/);
    public native @ByVal procedures find_procedures();
    public native @ByVal procedures find_procedures(
            @StdWString IntPointer procedure/*=nanodbc::string()*/,
            @StdWString IntPointer schema/*=nanodbc::string()*/,
            @StdWString IntPointer catalog/*=nanodbc::string()*/);

    /** \brief Creates result set with columns in one or more procedures.
     * 
     *  Columns information is obtained by executing {@code SQLProcedureColumns} function within
     *  scope of the connected database accessible with the specified connection.
     *  Since this function is implemented in terms of the {@code SQLProcedureColumns}, it returns
     *  result set ordered by PROCEDURE_CAT, PROCEDURE_SCHEM, PROCEDURE_NAME, and
     *  COLUMN_TYPE.
     * 
     *  All arguments are treated as the Pattern Value Arguments.
     *  Empty string argument is equivalent to passing the search pattern '%'. */
    
    ///
    public native @ByVal procedure_columns find_procedure_columns(
            @StdWString CharPointer column/*=nanodbc::string()*/,
            @StdWString CharPointer procedure/*=nanodbc::string()*/,
            @StdWString CharPointer schema/*=nanodbc::string()*/,
            @StdWString CharPointer catalog/*=nanodbc::string()*/);
    public native @ByVal procedure_columns find_procedure_columns();
    public native @ByVal procedure_columns find_procedure_columns(
            @StdWString IntPointer column/*=nanodbc::string()*/,
            @StdWString IntPointer procedure/*=nanodbc::string()*/,
            @StdWString IntPointer schema/*=nanodbc::string()*/,
            @StdWString IntPointer catalog/*=nanodbc::string()*/);

    /** \brief Returns names of all catalogs (or databases) available in connected data source.
     * 
     *  Executes {@code SQLTable} function with {@code SQL_ALL_CATALOG} as catalog search pattern. */
    
    ///
    public native @ByVal StringList list_catalogs();

    /** \brief Returns names of all schemas available in connected data source.
     * 
     *  Executes {@code SQLTable} function with {@code SQL_ALL_SCHEMAS} as schema search pattern. */
    public native @ByVal StringList list_schemas();
}

/** \} */

// clang-format off
// 8888888888                            8888888888                         888    d8b
// 888                                   888                                888    Y8P
// 888                                   888                                888
// 8888888 888d888 .d88b.   .d88b.       8888888 888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.  .d8888b
// 888     888P"  d8P  Y8b d8P  Y8b      888     888  888 888 "88b d88P"    888    888 d88""88b 888 "88b 88K
// 888     888    88888888 88888888      888     888  888 888  888 888      888    888 888  888 888  888 "Y8888b.
// 888     888    Y8b.     Y8b.          888     Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888      X88
// 888     888     "Y8888   "Y8888       888      "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888  88888P'
// MARK: Free Functions -
// clang-format on

/** \addtogroup mainf Free Functions
/** \brief Convenience functions.
/**
/** \{
<p>
/** \brief Information on a configured ODBC driver. */
@Name("nanodbc::driver") public static class Driver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Driver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Driver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Driver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Driver position(long position) {
        return (Driver)super.position(position);
    }
    @Override public Driver getPointer(long i) {
        return new Driver((Pointer)this).offsetAddress(i);
    }

    /** \brief Driver attributes. */
    @Name("attribute") public static class Attribute extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public Attribute() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Attribute(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Attribute(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public Attribute position(long position) {
            return (Attribute)super.position(position);
        }
        @Override public Attribute getPointer(long i) {
            return new Attribute((Pointer)this).offsetAddress(i);
        }
    
        /** Driver keyword attribute. */
        public native @StdWString CharPointer keyword(); public native Attribute keyword(CharPointer setter);
        /** Driver attribute value. */
        public native @StdWString CharPointer value(); public native Attribute value(CharPointer setter);
    }

    /** Driver name. */
    public native @StdWString CharPointer name(); public native Driver name(CharPointer setter);
    /** List of driver attributes. */
    public native @ByRef DriverAttributeList attributes(); public native Driver attributes(DriverAttributeList setter);
}

@Name("nanodbc::datasource") public static class Datasource extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Datasource() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Datasource(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Datasource(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Datasource position(long position) {
        return (Datasource)super.position(position);
    }
    @Override public Datasource getPointer(long i) {
        return new Datasource((Pointer)this).offsetAddress(i);
    }

    /** DSN name. */
    public native @StdWString CharPointer name(); public native Datasource name(CharPointer setter);
    /** Driver description. */
    public native @StdWString CharPointer driver(); public native Datasource driver(CharPointer setter);
}

/** \brief Returns a list of ODBC drivers on your system. */
@Namespace("nanodbc") public static native @ByVal DriverList list_drivers();

/** \brief Returns a list of ODBC data sources on your system. */
@Namespace("nanodbc") public static native @ByVal DatasourceList list_datasources();

/** \brief Immediately opens, prepares, and executes the given query directly on the given
 *  connection.
 *  @param conn The connection where the statement will be executed.
 *  @param query The SQL query that will be executed.
 *  @param batch_operations Numbers of rows to fetch per rowset, or the number of batch parameters
 *  to process.
 *  @param timeout The number in seconds before query timeout. Default is 0 indicating no timeout.
 *  @return A result set object.
 *  \attention You will want to use transactions if you are doing batch operations because it will
 *             prevent auto commits from occurring after each individual operation is executed.
 *  @see open(), prepare(), execute(), result, transaction */
@Namespace("nanodbc") public static native @ByVal Result execute(@ByRef Connection conn, @StdWString CharPointer query, long batch_operations/*=1*/, long timeout/*=0*/);
@Namespace("nanodbc") public static native @ByVal Result execute(@ByRef Connection conn, @StdWString CharPointer query);
@Namespace("nanodbc") public static native @ByVal Result execute(@ByRef Connection conn, @StdWString IntPointer query, long batch_operations/*=1*/, long timeout/*=0*/);
@Namespace("nanodbc") public static native @ByVal Result execute(@ByRef Connection conn, @StdWString IntPointer query);

/** \brief Opens, prepares, and executes query directly without creating result object.
 *  @param conn The connection where the statement will be executed.
 *  @param query The SQL query that will be executed.
 *  @param batch_operations Rows to fetch per rowset, or number of batch parameters to process.
 *  @param timeout The number in seconds before query timeout. Default is 0 indicating no timeout.
 *  @return A result set object.
 *  \attention You will want to use transactions if you are doing batch operations because it will
 *             prevent auto commits from occurring after each individual operation is executed.
 *  @see open(), prepare(), execute(), result, transaction */
@Namespace("nanodbc") public static native void just_execute(
    @ByRef Connection conn,
    @StdWString CharPointer query,
    long batch_operations/*=1*/,
    long timeout/*=0*/);
@Namespace("nanodbc") public static native void just_execute(
    @ByRef Connection conn,
    @StdWString CharPointer query);
@Namespace("nanodbc") public static native void just_execute(
    @ByRef Connection conn,
    @StdWString IntPointer query,
    long batch_operations/*=1*/,
    long timeout/*=0*/);
@Namespace("nanodbc") public static native void just_execute(
    @ByRef Connection conn,
    @StdWString IntPointer query);

/** \brief Execute the previously prepared query now.
 *  @param stmt The prepared statement that will be executed.
 *  @param batch_operations Rows to fetch per rowset, or the number of batch parameters to process.
 *  @throws database_error
 *  @return A result set object.
 *  \attention You will want to use transactions if you are doing batch operations because it will
 *             prevent auto commits from occurring after each individual operation is executed.
 *  @see open(), prepare(), execute(), result */
@Namespace("nanodbc") public static native @ByVal Result execute(@ByRef Statement stmt, long batch_operations/*=1*/);
@Namespace("nanodbc") public static native @ByVal Result execute(@ByRef Statement stmt);

/** \brief Execute the previously prepared query now and without creating result object.
 *  @param stmt The prepared statement that will be executed.
 *  @param batch_operations Rows to fetch per rowset, or the number of batch parameters to process.
 *  @throws database_error
 *  @return A result set object.
 *  \attention You will want to use transactions if you are doing batch operations because it will
 *             prevent auto commits from occurring after each individual operation is executed.
 *  @see open(), prepare(), execute(), result */

///
@Namespace("nanodbc") public static native void just_execute(@ByRef Statement stmt, long batch_operations/*=1*/);
@Namespace("nanodbc") public static native void just_execute(@ByRef Statement stmt);

/** \brief Execute the previously prepared query now.
 * 
 *  Executes within the context of a transaction object, commits directly after execution.
 *  @param stmt The prepared statement that will be executed in batch.
 *  @param batch_operations Rows to fetch per rowset, or the number of batch parameters to process.
 *  @throws database_error
 *  @return A result set object.
 *  @see open(), prepare(), execute(), result, transaction */

///
@Namespace("nanodbc") public static native @ByVal Result transact(@ByRef Statement stmt, long batch_operations);

/** \brief Execute the previously prepared query now and without creating result object.
 * 
 *  Executes within the context of a transaction object, commits directly after execution.
 *  @param stmt The prepared statement that will be executed in batch.
 *  @param batch_operations Rows to fetch per rowset, or the number of batch parameters to process.
 *  @throws database_error
 *  @return A result set object.
 *  @see open(), prepare(), execute(), result, transaction */

///
@Namespace("nanodbc") public static native void just_transact(@ByRef Statement stmt, long batch_operations);

/** \brief Prepares the given statement to execute on it associated connection.
 * 
 *  If the statement is not open throws programming_error.
 *  @param stmt The prepared statement that will be executed in batch.
 *  @param query The SQL query that will be executed.
 *  @param timeout The number in seconds before query timeout. Default is 0 indicating no timeout.
 *  @see open()
 *  @throws database_error, programming_error */
@Namespace("nanodbc") public static native void prepare(@ByRef Statement stmt, @StdWString CharPointer query, long timeout/*=0*/);
@Namespace("nanodbc") public static native void prepare(@ByRef Statement stmt, @StdWString CharPointer query);
@Namespace("nanodbc") public static native void prepare(@ByRef Statement stmt, @StdWString IntPointer query, long timeout/*=0*/);
@Namespace("nanodbc") public static native void prepare(@ByRef Statement stmt, @StdWString IntPointer query);

/** \} */

 // namespace nanodbc

// #endif


}
